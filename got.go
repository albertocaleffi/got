package got

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"strings"
)

// Template represents an entire got template.
// A template consists of zero or more blocks.
// Blocks can be either a TextBlock or a CodeBlock.
type Template struct {
	Path   string
	Blocks []Block
}

// WriteTo writes the template to a writer.
func (t *Template) WriteTo(w io.Writer) (n int64, err error) {
	var buf bytes.Buffer

	// Write "generated" header comment.
	buf.WriteString("// Generated by got.\n")
	buf.WriteString("// DO NOT EDIT\n\n")

	// Write blocks.
	writeBlocksTo(&buf, t.Blocks)

	// Parse buffer as a Go file.
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", buf.Bytes(), parser.ParseComments)
	if err != nil {
		n, _ = buf.WriteTo(w)
		return n, err
	}

	// Inject required packages.
	injectImports(f)

	// Attempt to gofmt.
	var result bytes.Buffer
	if err := format.Node(&result, fset, f); err != nil {
		n, _ = buf.WriteTo(w)
		return n, err
	}

	// Write to output writer.
	return result.WriteTo(w)
}

func writeBlocksTo(buf *bytes.Buffer, blks []Block) {
	for _, blk := range blks {
		// Write line comment.
		if pos := Position(blk); pos.Path != "" && pos.LineNo > 0 {
			fmt.Fprintf(buf, "//line %s:%d\n", pos.Path, pos.LineNo)
		}

		// Write block.
		switch blk := blk.(type) {
		case *TextBlock:
			fmt.Fprintf(buf, `_, _ = io.WriteString(w, %q)`+"\n", blk.Content)

		case *CodeBlock:
			fmt.Fprintln(buf, blk.Content)
		}
	}
}

// Normalize joins together adjacent text blocks.
func normalizeBlocks(a []Block) []Block {
	a = joinAdjacentTextBlocks(a)
	a = trimTrailingEmptyTextBlocks(a)
	return a
}

func joinAdjacentTextBlocks(a []Block) []Block {
	var other []Block
	for _, blk := range a {
		curr, isTextBlock := blk.(*TextBlock)

		// Always append the first block.
		if len(other) == 0 {
			other = append(other, blk)
			continue
		}

		// Simply append if this block or prev block are not text blocks.
		prev, isPrevTextBlock := other[len(other)-1].(*TextBlock)
		if !isTextBlock || !isPrevTextBlock {
			other = append(other, blk)
			continue
		}

		// Append this text block's content to the previous block.
		prev.Content += curr.Content
	}

	return other
}

func trimTrailingEmptyTextBlocks(a []Block) []Block {
	for len(a) > 0 {
		blk, ok := a[len(a)-1].(*TextBlock)
		if !ok || strings.TrimSpace(blk.Content) != "" {
			break
		}
		a[len(a)-1] = nil
		a = a[:len(a)-1]
	}
	return a
}

func injectImports(f *ast.File) {
	names := []string{`"fmt"`, `"html"`, `"io"`, `"context"`}

	// Strip packages from existing imports.
	for i := 0; i < len(f.Decls); i++ {
		decl, ok := f.Decls[i].(*ast.GenDecl)
		if !ok || decl.Tok != token.IMPORT {
			continue
		}

		// Remove listed imports.
		removeImportSpecs(decl, names)

		// Remove declaration if it has no imports.
		if len(decl.Specs) == 0 {
			copy(f.Decls[i:], f.Decls[i+1:])
			f.Decls[len(f.Decls)-1] = nil
			f.Decls = f.Decls[:len(f.Decls)-1]
			i--
		}
	}

	// Generate new import.
	for i := len(names) - 1; i >= 0; i-- {
		f.Decls = append([]ast.Decl{&ast.GenDecl{
			Tok: token.IMPORT,
			Specs: []ast.Spec{
				&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: names[i]}},
			},
		}}, f.Decls...)
	}

	// Add unnamed vars at the end of the file to ensure imports are used.
	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{Names: []*ast.Ident{{Name: "_"}}, Type: &ast.Ident{Name: "fmt.Stringer"}},
		},
	})
	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{Names: []*ast.Ident{{Name: "_"}}, Type: &ast.Ident{Name: "io.Reader"}},
		},
	})
	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{Names: []*ast.Ident{{Name: "_"}}, Type: &ast.Ident{Name: "context.Context"}},
		},
	})
	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{Names: []*ast.Ident{{Name: "_"}}, Values: []ast.Expr{&ast.Ident{Name: "html.EscapeString"}}},
		},
	})
}

func removeImportSpecs(decl *ast.GenDecl, names []string) {
	for i := 0; i < len(decl.Specs); i++ {
		spec, ok := decl.Specs[i].(*ast.ImportSpec)
		if !ok || !stringSliceContains(names, spec.Path.Value) {
			continue
		}

		// Delete spec.
		copy(decl.Specs[i:], decl.Specs[i+1:])
		decl.Specs[len(decl.Specs)-1] = nil
		decl.Specs = decl.Specs[:len(decl.Specs)-1]

		i--
	}
}

// Block represents an element of the template.
type Block interface {
	block()
}

func (*TextBlock) block()	{}
func (*CodeBlock) block()	{}

// PassBlock represents a UTF-8 encoded block of text that is written to the writer as-is.
type TextBlock struct {
	Pos     Pos
	Content string
}

// CodeBlock represents a Go code block that is printed as-is to the template.
type CodeBlock struct {
	Pos     Pos
	Content string
}

// Position returns the position of the block.
func Position(blk Block) Pos {
	switch blk := blk.(type) {
	case *TextBlock:
		return blk.Pos
	case *CodeBlock:
		return blk.Pos
	default:
		panic("Invalid block type")
	}
}

// Pos represents a position in a given file.
type Pos struct {
	Path   string
	LineNo int
}

func stringSliceContains(a []string, v string) bool {
	for i := range a {
		if a[i] == v {
			return true
		}
	}
	return false
}
