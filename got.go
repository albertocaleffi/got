package got

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"strings"
)

// Template represents an entire got template.
// A template consists of zero or more blocks.
// Blocks can be either a TextBlock or a CodeBlock.
type Template struct {
	Path   string
	Blocks []Block
}

// WriteTo writes the template to a writer.
func (t *Template) WriteTo(w io.Writer) (n int64, err error) {
	var buf bytes.Buffer

	// Write "generated" header comment.
	buf.WriteString("// Generated by got.\n")
	buf.WriteString("// DO NOT EDIT\n\n")

	// Write blocks.
	writeBlocksTo(&buf, t.Blocks)

	// Parse buffer as a Go file.
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", buf.Bytes(), parser.ParseComments)
	if err != nil {
		n, _ = buf.WriteTo(w)
		return n, err
	}

	// Attempt to gofmt.
	var result bytes.Buffer
	if err := format.Node(&result, fset, f); err != nil {
		n, _ = buf.WriteTo(w)
		return n, err
	}

	// Write to output writer.
	return result.WriteTo(w)
}

func writeBlocksTo(buf *bytes.Buffer, blks []Block) {
	for _, blk := range blks {
		// Skip empty blocks.
		if blk.empty() {
			continue
		}

		// Write line comment.
		if pos := Position(blk); pos.Path != "" && pos.LineNo > 0 {
			fmt.Fprintf(buf, "//line %s:%d\n", pos.Path, pos.LineNo)
		}

		// Write block.
		switch blk := blk.(type) {
		case *TextBlock:
			fmt.Fprintf(buf, `_, _ = io.WriteString(w, %q)`+"\n",
				blk.Content)

		case *CodeBlock:
			fmt.Fprintln(buf, blk.Content)
		}
	}
}

// Normalize joins together adjacent text blocks.
func normalizeBlocks(a []Block) []Block {
	a = joinAdjacentTextBlocks(a)
	a = trimLeadingEmptyBlocks(a)
	a = trimTrailingEmptyBlocks(a)
	return a
}

func joinAdjacentTextBlocks(a []Block) []Block {
	var other []Block
	for _, blk := range a {
		curr, isTextBlock := blk.(*TextBlock)

		// Always append the first block.
		if len(other) == 0 {
			other = append(other, blk)
			continue
		}

		// Simply append if this block or prev block are not text blocks.
		prev, isPrevTextBlock := other[len(other)-1].(*TextBlock)
		if !isTextBlock || !isPrevTextBlock {
			other = append(other, blk)
			continue
		}

		// Append this text block's content to the previous block.
		prev.Content += curr.Content
	}

	return other
}

func trimLeadingEmptyBlocks(a []Block) []Block {
	for i := 0; i < len(a); i++ {
		if !a[i].empty() {
			break
		}
		a = a[1:]
	}
	return a
}

func trimTrailingEmptyBlocks(a []Block) []Block {
	for len(a) > 0 {
		if !a[len(a)-1].empty() {
			break
		}
		a[len(a)-1] = nil
		a = a[:len(a)-1]
	}
	return a
}

// Block represents an element of the template.
type Block interface {
	block()
	empty() bool
}

// PassBlock represents a UTF-8 encoded block of text that is written to the writer as-is.
type TextBlock struct {
	Pos     Pos
	Content string
}

func (*TextBlock) block() {
}

func (b *TextBlock) empty() bool {
	return strings.TrimSpace(b.Content) == ""
}

// CodeBlock represents a Go code block that is printed as-is to the template.
type CodeBlock struct {
	Pos     Pos
	Content string
}

func (*CodeBlock) block() {
}

func (b *CodeBlock) empty() bool {
	return strings.TrimSpace(b.Content) == ""
}

// Position returns the position of the block.
func Position(blk Block) Pos {
	switch blk := blk.(type) {
	case *TextBlock:
		return blk.Pos
	case *CodeBlock:
		return blk.Pos
	default:
		panic("Invalid block type")
	}
}

// Pos represents a position in a given file.
type Pos struct {
	Path   string
	LineNo int
}

func stringSliceContains(a []string, v string) bool {
	for i := range a {
		if a[i] == v {
			return true
		}
	}
	return false
}
